<h1 id="✔-문제">✔ 문제</h1>
<blockquote>
<p>적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다.
크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다. 그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다. 또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다. (색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다)
예를 들어, 그림이 아래와 같은 경우에</p>
</blockquote>
<p>RRRBB
GGBBB
BBBRR
BBRRR
RRRRR</p>
<blockquote>
<p>적록색약이 아닌 사람이 봤을 때 구역의 수는 총 4개이다. (빨강 2, 파랑 1, 초록 1) 하지만, 적록색약인 사람은 구역을 3개 볼 수 있다. (빨강-초록 2, 파랑 1)
그림이 입력으로 주어졌을 때, 적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오.</p>
</blockquote>
<br />

<h1 id="✔-입력">✔ 입력</h1>
<blockquote>
<p>첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100)
둘째 줄부터 N개 줄에는 그림이 주어진다.</p>
</blockquote>
<br />

<h1 id="✔-출력">✔ 출력</h1>
<blockquote>
<p>적록색약이 아닌 사람이 봤을 때의 구역의 개수와 적록색약인 사람이 봤을 때의 구역의 수를 공백으로 구분해 출력한다.</p>
</blockquote>
<br />

<h1 id="🥊-나의-해결-과정">🥊 나의 해결 과정</h1>
<ul>
<li>문제에 구역 이야기가 나올 때부터 &quot;이건 bfs 문제다&quot; 생각이 들었다.</li>
<li>색약자는 포함 범위가 더 넒으니 큐를 따로 두어야겠다는 생각은 금방 들었다.</li>
<li>bfs 를 수행하는 함수를 일반인, 색약자 따로 만들어야하나? 라고 생각했지만</li>
<li><blockquote>
<p>코드 중복이 많이 생기니 패스. 이 방법이 정답일 것 같지는 않았다.</p>
</blockquote>
</li>
<li>bfs() 수행 후 반환할 때 구역 수를 증가해야하나? 생각했지만</li>
<li><blockquote>
<p>그렇게 하면 일반인과 적록색약자가 매번 동시에 구역 증가가 일아나니 불가능.</p>
</blockquote>
</li>
<li>결론</li>
<li><blockquote>
<p>기준 색상과 이동 구역 색상이 같은 경우 두명 모두에게 같은 구역이므로 일반인 큐에만 추가해도 됨. 방문 체크는 두명 모두 true</p>
</blockquote>
</li>
<li><blockquote>
<p>기준 색상과 이동 구역 색상이 다른 경우 두 색 모두 'B' 가 아니면 색약자는 동일하게 취급하는 'R','G' 이므로 색약자 큐에만 추가 및 방문 true</p>
</blockquote>
</li>
<li><blockquote>
<p>일반 큐 탐색 후 색약자 큐를 추가로 탐색하여 색약자의 구역 범위를 넓힘</p>
</blockquote>
</li>
<li><blockquote>
<p>일반인은 더 세분화 해서 색을 구분하므로 마지막으로 일반인 방문 체크 배열을 돌며 체크되지 않은 구역이 있는지 확인.</p>
</blockquote>
</li>
</ul>
<br />

<ul>
<li>아무런 코드 참고 없이 혼자 푼거라서 더 좋은 풀이가 있는지 찾아봐야겠다.</li>
<li>bfs 문제 한정이긴 하지만 G5 난이도 문제를 혼자 힘으로 풀 정도는 되나 싶어서 조금 뿌듯하다.
<img alt="" src="https://velog.velcdn.com/images/conam/post/a3094ac7-5a5a-41f9-b37c-b6df83333a63/image.png" /></li>
</ul>
<br />

<h1 id="💖-나의-정답-코드">💖 나의 정답 코드</h1>
<pre><code>/**백준 10026.G5.적록색약**/
/**
 * ## 체감 난이도 ##
 * - 열심히 하니까 풀 수 있는 정도였다.
 * - G5 난이도 정도로 적절하게 느껴졌다.
 * - 이제 bfs 문제는 어느 정도 감이 잡히는거 같다.
 * - 문제가 풀릴 듯 말듯 해서 끝까지 잡고 있었더니 결국 정답 참고 없이 풀었다.
 * ## 핵심 내용 ##
 * - 색약자가 일반인 보다 구역을 더 넓게 쓰므로 색약자 방문 여부 부터 체크(그러나 동시에 일반인도 같이 체크됨)
 * - 만약 일반인 먼저 방문 여부를 체크한다면 색약자 구역이 정답보다 더 많게 체크될 수 있다.(일반인은 더 많은 범위를 보기 때문)
 * - 큐를 두개 두어 일반 범위가 아니면서 색약자 구역이면 specialQ 에 추가하여 색약자 구역 추가 체크
 * - 색약자 구역을 먼저 방문 체크해서 일반인 구역은 방문하지 않은 요소가 있을 수 있으므로 마지막에 방문 체크
 * - 다른 풀이를 아예 참고하지 않아서 다른 더 좋은 풀이가 있는지 확인해봐야겠다.
 **/
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.util.Queue;
import java.util.LinkedList;
public class Main {
    static int N;
    static int[] dx = {-1, 1, 0, 0}; // 상, 하, 좌, 우
    static int[] dy = {0, 0, -1, 1};
    static char[][] picture;
    static Queue&lt;int[]&gt; normalQ = new LinkedList&lt;&gt;(); // 일반인 큐
    static Queue&lt;int[]&gt; specialQ = new LinkedList&lt;&gt;(); // 색약자 큐
    static boolean[][] normalVisited; // 일반인 방문
    static boolean[][] specialVisited; // 색약자 방문
    static int normal = 0, special = 0;
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        N = Integer.parseInt(br.readLine());
        picture = new char[N][N];
        normalVisited = new boolean[N][N]; 
        specialVisited = new boolean[N][N];

        char[] line;
        for (int i = 0; i &lt; N; i++) {
            line = br.readLine().toCharArray();
            for (int j = 0; j &lt; N; j++) {
                picture[i][j] = line[j];
            }
        }

        for (int i = 0; i &lt; N; i++) {
            for (int j = 0; j &lt; N; j++) {
                if (specialVisited[i][j]) continue; // 색약자 먼저 방문 체크

                // 사실상 방문하지 않은 구역일 때만 큐에 추가하고 bfs 로 탐색하는 구조
                normalQ.offer(new int[]{i, j}); // 색약자가 방문하지 않은 곳이면 일반인은 당연히 방문하지 않은 구역임
                normalVisited[i][j] = true; 
                specialVisited[i][j] = true;
                bfs(picture[i][j]); // 사실상 bfs 는 방문 체크 용도
                ++normal; // 일반인 구역 추가. 일반인은 더 많은 구역을 볼 수 있으므로 색약자가 볼 수 있는 구역은 당연히 일반인도 볼 수 있는 구역.
                ++special; // 색약자 구역 추가.
            }
        }

        for (int i = 0; i &lt; N; i++) {
            for (int j = 0; j &lt; N; j++) {
                if (normalVisited[i][j]) continue;

                // 일반인 방문 체크 안된 곳 탐색
                // bfs() 코드에서 일반인은 R, G 컬러를 다른 컬러로 보기 때문에 방문 체크 안돼있음
                normalQ.offer(new int[]{i, j});
                normalVisited[i][j] = true;

                bfs(picture[i][j]);
                ++normal; // 일반인 구역 추가
            }
        }

        bw.write(normal + &quot; &quot; + special + &quot;\n&quot;);
        bw.flush();
        bw.close();
        br.close();
    }

    /** bfs 수행 **/
    private static void bfs(char mainColor) {
        int[] curPoint;
        int nx, ny;
        while (!normalQ.isEmpty()) { // 일반인 bfs But, 조건에 맞는 경우 색약자 방문 체크도 같이함.
            curPoint = normalQ.poll();

            for (int i = 0; i &lt; 4; i++) {
                nx = curPoint[0] + dx[i];
                ny = curPoint[1] + dy[i];

                if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; N &amp;&amp; !normalVisited[nx][ny]) { // 배열 범위 내부이고 방문하지 않은 곳인 경우
                    if (mainColor == picture[nx][ny]) { // 기준 색과 이동 가능한 곳의 색이 같으면
                        normalQ.offer(new int[]{nx, ny});
                        normalVisited[nx][ny] = true;
                        specialVisited[nx][ny] = true; // 색이 동일한 경우 일반인과 색약자 모두 같은 구역이 맞음.
                    }
                    else if (mainColor != 'B' &amp;&amp;  picture[nx][ny] != 'B' &amp;&amp; !specialVisited[nx][ny]) { // 기준 색과 이동 가능한 곳의 색이 다르면서 두 색 모두 'B'가 아닌 경우
                        specialQ.offer(new int[]{nx, ny}); // 적록색약자는 R,G 는 같은 구역이므로 색약자 큐에만 추가 및 방문 체크
                        specialVisited[nx][ny] = true;
                    }
                }
            }
        }

        while (!specialQ.isEmpty()) { // 색약자 구역만 다시 체크
            curPoint = specialQ.poll();

            for (int i = 0; i &lt; 4; i++) {
                nx = curPoint[0] + dx[i];
                ny = curPoint[1] + dy[i];

                if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; N &amp;&amp; !specialVisited[nx][ny]) {
                    if (picture[nx][ny] != 'B') { // 기준 색이 'B' 가 아닌 경우만 색약자 큐에 추가되므로 이동한 곳 색이 'B'가 아닌지만 체크하면 됨.
                        specialQ.offer(new int[]{nx, ny});
                        specialVisited[nx][ny] = true;
                    }
                }
            }
        }

    }
}</code></pre>