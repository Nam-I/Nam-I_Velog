<h1 id="✔-문제">✔ 문제</h1>
<blockquote>
<p>RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.</p>
</blockquote>
<ul>
<li>1번 집의 색은 2번 집의 색과 같지 않아야 한다.</li>
<li>N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.</li>
<li>i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.</li>
</ul>
<h1 id="✔-입력">✔ 입력</h1>
<blockquote>
<p>첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.</p>
</blockquote>
<h1 id="✔-출력">✔ 출력</h1>
<blockquote>
<p>첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.</p>
</blockquote>
<br />

<h1 id="🥊-나의-해결-과정">🥊 나의 해결 과정</h1>
<ul>
<li>문제 유형을 최소 비용 문제라서 DP 문제라는 것을 눈치챘다.</li>
<li>점화식을 어렴풋이 감이 잡히긴 했는데 누적 값을 어떻게 내야하지? 의문이 들었다.</li>
<li>집 번호를 인덱스, 색깔을 컬럼으로 두어서 배열 요소에 값을 누적한다.</li>
<li>현재 집 색을 정하고 다음 색을 무슨 색으로 칠할까? 가 아니라</li>
<li><blockquote>
<p>현재 집 색을 정하고 이전 값으로 칠할 수 있는 색을 정하는 방식</p>
</blockquote>
</li>
<li>빨강, 초록, 파랑 으로 칠하는 모든 경우의 수를 구함</li>
<li><blockquote>
<p>dp[N]<a href="https://api.velog.io/rss/%EB%B9%A8%EA%B0%95">0</a>, dp[N]<a href="https://api.velog.io/rss/%EC%B4%88%EB%A1%9D">1</a>, dp[N]<a href="https://api.velog.io/rss/%ED%8C%8C%EB%9E%91">2</a> 을 Math.min() 해서 최소 값이 정답이다.</p>
</blockquote>
</li>
<li>재귀로 풀 수 있지만 일반적으로 반복문이 더 빠르고 스택 오버플로우 위험도 없어서 반복문 방식으로만 풀었다.</li>
</ul>
<br />

<p><img alt="" src="https://velog.velcdn.com/images/conam/post/c9ef9f2e-cca4-476c-b0d5-f64948d368b3/image.png" /></p>
<br />

<h1 id="💖-나의-정답-풀이">💖 나의 정답 풀이</h1>
<pre><code>/** 백준 1149.S1.RGB거리 - Bottom up 반복문 DP java 풀이
 * ## 체감 난이도 ##
 * - 대충 어떤 식을 점화식을 세워야하는지 어렴풋이 떠오르긴 해서 S1 난이도는 적절한 듯하다.
 * - 하지만 아직 DP 문제는 쉽게 풀리진 않는거 같다.
 * ## 핵심 내용 ##
 * - DP 문제는 인접 리스트 그려보면서 점화식 세워보기
 * - 재귀로도 풀 수 있으나 일반적으로 반복문으로 풀 수 있으면 반복문이 더 빠르기 때문에 
 * 반목문으로만 풀었다.
 **/
import java.io.IOException;
import java.io.BufferedWriter;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Main  {
    static int N;
    static long[][] dp;
    public static void main (String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st;

        N = Integer.parseInt(br.readLine());
        dp = new long[N+1][3];

        for (int i = 1; i &lt;= N; i++) {
            st = new StringTokenizer(br.readLine());
            int red = Integer.parseInt(st.nextToken()); //빨
            int green = Integer.parseInt(st.nextToken()); //초
            int blue = Integer.parseInt(st.nextToken()); //파

            dp[i][0] = Math.min(dp[i-1][1], dp[i-1][2]) + red; // i 번째 집을 빨강으로 칠하면 인접한 이전 집은 초록 or 파랑 그 중 최소 선택
            dp[i][1] = Math.min(dp[i-1][0], dp[i-1][2]) + green;
            dp[i][2] = Math.min(dp[i-1][0], dp[i-1][1]) + blue;
        }

        bw.write(Math.min(Math.min(dp[N][0], dp[N][1]), dp[N][2]) + &quot;\n&quot;);
        bw.flush();
        bw.close();
        br.close();
    }
}</code></pre>