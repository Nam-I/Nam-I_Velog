<h1 id="âœ”-ë¬¸ì œ">âœ” ë¬¸ì œ</h1>
<blockquote>
<p>Nê°œì˜ ìì—°ìˆ˜ì™€ ìì—°ìˆ˜ Mì´ ì£¼ì–´ì¡Œì„ ë•Œ, ì•„ë˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê¸¸ì´ê°€ Mì¸ ìˆ˜ì—´ì„ ëª¨ë‘ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.
Nê°œì˜ ìì—°ìˆ˜ ì¤‘ì—ì„œ Mê°œë¥¼ ê³ ë¥¸ ìˆ˜ì—´</p>
</blockquote>
<h1 id="âœ”-ì…ë ¥">âœ” ì…ë ¥</h1>
<blockquote>
<p>ì²«ì§¸ ì¤„ì— Nê³¼ Mì´ ì£¼ì–´ì§„ë‹¤. (1 â‰¤ M â‰¤ N â‰¤ 8)
ë‘˜ì§¸ ì¤„ì— Nê°œì˜ ìˆ˜ê°€ ì£¼ì–´ì§„ë‹¤. ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§€ëŠ” ìˆ˜ëŠ” 10,000ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ìì—°ìˆ˜ì´ë‹¤.</p>
</blockquote>
<h1 id="âœ”-ì¶œë ¥">âœ” ì¶œë ¥</h1>
<blockquote>
<p>í•œ ì¤„ì— í•˜ë‚˜ì”© ë¬¸ì œì˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìˆ˜ì—´ì„ ì¶œë ¥í•œë‹¤. ì¤‘ë³µë˜ëŠ” ìˆ˜ì—´ì„ ì—¬ëŸ¬ ë²ˆ ì¶œë ¥í•˜ë©´ ì•ˆë˜ë©°, ê° ìˆ˜ì—´ì€ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•´ì„œ ì¶œë ¥í•´ì•¼ í•œë‹¤.
ìˆ˜ì—´ì€ ì‚¬ì „ ìˆœìœ¼ë¡œ ì¦ê°€í•˜ëŠ” ìˆœì„œë¡œ ì¶œë ¥í•´ì•¼ í•œë‹¤.</p>
</blockquote>
<br />


<h1 id="ğŸ¥Š-ë‚˜ì˜-ë¬¸ì œ-í•´ê²°-ê³¼ì •">ğŸ¥Š ë‚˜ì˜ ë¬¸ì œ í•´ê²° ê³¼ì •</h1>
<ul>
<li>ì •ì„ì ì¸ ë°±íŠ¸ë˜í‚¹ + ì¬ê·€ ë°©ì‹ìœ¼ë¡œ í‘¸ëŠ” ë°©ë²•ê³¼ ì´ì „ ê°’ ì €ì¥ìœ¼ë¡œ í‘¸ëŠ” ë°©ì‹ì´ ìˆë‹¤.</li>
<li>ê°™ì€ depth ì—ì„œ ì´ì „ ê°’ì„ ì €ì¥í•˜ëŠ” í’€ì´ê°€ ë” ë¹ ë¥´ê³  ì¬ê·€ í˜¸ì¶œì„ ì•ˆí•˜ê¸° ë•Œë¬¸ì— ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ìœ„í—˜ì„ í”¼í•  ìˆ˜ ìˆë‹¤.</li>
<li>ì¬ê·€ í’€ì´ëŠ” ì´ë¯¸ íƒìƒ‰í•œ ìˆ˜ì—´ì´ë”ë¼ë„ íƒìƒ‰ì„ í•˜ê³  set ì— ì¶”ê°€í•˜ëŠ” ë°©ì‹ì´ë¯€ë¡œ ì‹œê°„ì´ ë‚­ë¹„ë˜ëŠ” ê²½í–¥ì´ ìˆë‹¤.<br />
![](https://velog.velcdn.com/images/conam/post/4bf8544e-a031-4718-83e8-7e0a95141f41/image.png)

</li>
</ul>
<br />

<h1 id="ğŸ’–-ë‚˜ì˜-ì •ë‹µ-í’€ì´">ğŸ’– ë‚˜ì˜ ì •ë‹µ í’€ì´</h1>
<p><strong>1. ì²«ë²ˆì§¸ í’€ì´ - ë°±íŠ¸ë˜í‚¹ + ì¬ê·€ í’€ì´</strong></p>
<pre><code>/** ë°±ì¤€ 15663.S2.Nê³¼ M(9) - LinkedHashSet ì¤‘ë³µ ì œê±° java í’€ì´
 * ## ì²´ê° ë‚œì´ë„ ##
 * - Nê³¼ M ì‹œë¦¬ì¦ˆë¥¼ ê½¤ í’€ì–´ë´¤ì§€ë§Œ ì´ë²ˆì—ëŠ” ë™ì¼í•œ ìˆ«ìê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°ë¥¼ ê³ ë ¤í•´ì•¼í•´ì„œ
 * ì¡°ê¸ˆ ë” ìƒê°í•  ê±°ë¦¬ê°€ ìˆì—ˆë‹¤.
 * - LinkedHashSet ìë£Œí˜•ì˜ íŠ¹ì§•ì„ ì•Œ ìˆ˜ ìˆëŠ” ë¬¸ì œì´ë‹¤.
 * ## í•µì‹¬ ë‚´ìš© ##
 * - prev ë³€ìˆ˜ë¥¼ ë‘ì–´ ê°™ì€ depth ì—ì„œ ì´ì „ì— ì‚¬ìš©í•œ ìˆ˜ë¥¼ í™•ì¸í•˜ëŠ” ë°©ë²•ì´ ì‹œê°„/ê³µê°„ ì¸¡ë©´ì—ì„œ ë” ì¢‹ë‹¤.
 * - í’€ì´ì—ì„œ ìë™ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬í•˜ëŠ” TreeSet ì‚¬ìš©í•˜ì§€ ì•Šê³  LinkedHashSetì„ ì“´ ì´ìœ 
 * : ë¬¸ìì—´ ì •ë ¬ì´ê¸° ë•Œë¬¸ì— ìˆ«ì ìƒ ì˜¤ë¦„ì°¨ìˆœì´ ì•„ë‹ˆë¼ ë¬¸ìì—´ ìƒ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ì´ ë˜ì–´
 * ë‹µì´ í‹€ë ¤ì§„ë‹¤. -&gt; LinkedHashSet ì€ ì…ë ¥ ìˆœì„œëŒ€ë¡œ ì •ë ¬, ì¤‘ë³µ ì œê±°ê°€ ê°€ëŠ¥í•˜ë¯€ë¡œ ë¬¸ì œì— ì ì ˆ
 **/
import java.io.*;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.StringTokenizer;
import java.util.Arrays;

public class Main {
    static int N, M;
    static HashSet&lt;String&gt; set;
    static int[] arr;
    static int[] resultArr;
    static boolean[] visited;
    static StringBuilder sb;
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        arr = new int[N];
        resultArr = new int[M];
        visited = new boolean[N];
        set = new LinkedHashSet&lt;&gt;();


        st = new StringTokenizer(br.readLine());

        for (int i = 0; i &lt; N; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        Arrays.sort(arr);
        backtracking(0);

        for (String s: set) {
            bw.write(s);
        }

        bw.flush();
        bw.close();
        br.close();

    }

    private static void backtracking(int depth) {
        if (depth == M) {
            sb = new StringBuilder();
            for (int i = 0; i &lt; M; i++) {
                sb.append(resultArr[i]).append(&quot; &quot;);
            }
            set.add(sb.append(&quot;\n&quot;).toString());
            return;
        }

        for (int i = 0; i &lt; N; i++) {
            if (visited[i]) continue;

            visited[i] = true;
            resultArr[depth] = arr[i];
            backtracking(depth + 1);
            visited[i] = false;
        }

    }
}</code></pre><br />

<p><strong>â­ 2. ë‘ë²ˆì§¸ í’€ì´ - ê°™ì€ depth ì´ì „ ê°’ ì €ì¥ í’€ì´</strong></p>
<pre><code>/** ë°±ì¤€ 15663.S2.Nê³¼ M(9) - prev ê°™ì€ depth ì´ì „ ì‚¬ìš© ê°’ ì €ì¥ java í’€ì´
 * ## ì²´ê° ë‚œì´ë„ ##
 * - Nê³¼ M ì‹œë¦¬ì¦ˆë¥¼ ê½¤ í’€ì–´ë´¤ì§€ë§Œ ì´ë²ˆì—ëŠ” ë™ì¼í•œ ìˆ«ìê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°ë¥¼ ê³ ë ¤í•´ì•¼í•´ì„œ
 * ì¡°ê¸ˆ ë” ìƒê°í•  ê±°ë¦¬ê°€ ìˆì—ˆë‹¤.
 * - LinkedHashSet ìë£Œí˜•ì˜ íŠ¹ì§•ì„ ì•Œ ìˆ˜ ìˆëŠ” ë¬¸ì œì´ë‹¤.
 * ## í•µì‹¬ ë‚´ìš© ##
 * - prev ë³€ìˆ˜ë¥¼ ë‘ì–´ ê°™ì€ depth ì—ì„œ ì´ì „ì— ì‚¬ìš©í•œ ìˆ˜ë¥¼ í™•ì¸í•˜ëŠ” ë°©ë²•ì´ ì‹œê°„/ê³µê°„ ì¸¡ë©´ì—ì„œ ë” ì¢‹ë‹¤.
 * - prev ë³€ìˆ˜ë¡œ ê°™ì€ depth ì—ì„œ ì´ì „ì— ì‚¬ìš©í•œ ê°’ì„ ì €ì¥í•´ë‘ë©´ ì¤‘ë³µ ìˆ˜ì—´ ìƒì„± ìì²´ë¥¼ ë§‰ì„ ìˆ˜ ìˆë‹¤.
 * - í’€ì´ì—ì„œ ìë™ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬í•˜ëŠ” TreeSet ì‚¬ìš©í•˜ì§€ ì•Šê³  LinkedHashSetì„ ì“´ ì´ìœ 
 * : ë¬¸ìì—´ ì •ë ¬ì´ê¸° ë•Œë¬¸ì— ìˆ«ì ìƒ ì˜¤ë¦„ì°¨ìˆœì´ ì•„ë‹ˆë¼ ë¬¸ìì—´ ìƒ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ì´ ë˜ì–´
 * ë‹µì´ í‹€ë ¤ì§„ë‹¤. -&gt; LinkedHashSet ì€ ì…ë ¥ ìˆœì„œëŒ€ë¡œ ì •ë ¬, ì¤‘ë³µ ì œê±°ê°€ ê°€ëŠ¥í•˜ë¯€ë¡œ ë¬¸ì œì— ì ì ˆ
 **/
import java.io.*;
import java.util.StringTokenizer;
import java.util.Arrays;

public class Main {
    static int N, M;
    static int[] arr;
    static int[] resultArr;
    static boolean[] visited;
    static StringBuilder sb = new StringBuilder();
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        arr = new int[N];
        resultArr = new int[M];
        visited = new boolean[N];

        st = new StringTokenizer(br.readLine());

        for (int i = 0; i &lt; N; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        Arrays.sort(arr);
        backtracking(0);

        bw.write(sb.toString());

        bw.flush();
        bw.close();
        br.close();

    }

    private static void backtracking(int depth) {
        if (depth == M) {
            for (int i = 0; i &lt; M; i++) {
                sb.append(resultArr[i]).append(&quot; &quot;);
            }
            sb.append(&quot;\n&quot;);
            return;
        }

        int prev = Integer.MIN_VALUE;

        for (int i = 0; i &lt; N; i++) {
            if (visited[i] || prev == arr[i]) continue;

            visited[i] = true;
            resultArr[depth] = arr[i];
            prev = arr[i];
            backtracking(depth + 1);
            visited[i] = false;
        }

    }
}
</code></pre>