<h1 id="✔-문제">✔ 문제</h1>
<blockquote>
<p>선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다. 이 언어에는 두 가지 함수 R(뒤집기)과 D(버리기)가 있다.
함수 R은 배열에 있는 수의 순서를 뒤집는 함수이고, D는 첫 번째 수를 버리는 함수이다. 배열이 비어있는데 D를 사용한 경우에는 에러가 발생한다.
함수는 조합해서 한 번에 사용할 수 있다. 예를 들어, &quot;AB&quot;는 A를 수행한 다음에 바로 이어서 B를 수행하는 함수이다. 예를 들어, &quot;RDD&quot;는 배열을 뒤집은 다음 처음 두 수를 버리는 함수이다.
배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램을 작성하시오.</p>
</blockquote>
<br />


<h1 id="✔-입력">✔ 입력</h1>
<blockquote>
<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 최대 100이다.
각 테스트 케이스의 첫째 줄에는 수행할 함수 p가 주어진다. p의 길이는 1보다 크거나 같고, 100,000보다 작거나 같다.
다음 줄에는 배열에 들어있는 수의 개수 n이 주어진다. (0 ≤ n ≤ 100,000)
다음 줄에는 [x1,...,xn]과 같은 형태로 배열에 들어있는 정수가 주어진다. (1 ≤ xi ≤ 100)
전체 테스트 케이스에 주어지는 p의 길이의 합과 n의 합은 70만을 넘지 않는다.</p>
</blockquote>
<br />

<h1 id="✔-출력">✔ 출력</h1>
<blockquote>
<p>각 테스트 케이스에 대해서, 입력으로 주어진 정수 배열에 함수를 수행한 결과를 출력한다. 만약, 에러가 발생한 경우에는 error를 출력한다.</p>
</blockquote>
<br />

<h1 id="🥊-나의-해결-과정">🥊 나의 해결 과정</h1>
<h3 id="1차-시도---실패">1차 시도 - 실패</h3>
<ul>
<li><p>Queue를 사용했고 R 연산 시 단순하게 큐를 매번 뒤집었다.</p>
</li>
<li><blockquote>
<p>결과: 시간초과</p>
</blockquote>
<h3 id="2차-시도---실패">2차 시도 - 실패</h3>
</li>
<li><p>출력에 공백이 있으면 안된다는 사실을 모르고 bw.write(q + \n) 형식으로 단순히 큐를 출력해버려서 실패</p>
</li>
<li><blockquote>
<p>결과: 틀렸습니다.</p>
</blockquote>
<h3 id="⭐-3차-시도----성공">⭐ 3차 시도  - 성공</h3>
</li>
<li><p>Deque 자료구조 사용으로 양쪽으로 삽입/삭제</p>
</li>
<li><p>애초에 R(뒤집기) 함수 동작은 구현할 필요가 없는거였다.</p>
</li>
<li><blockquote>
<p>isReversed/!isReversed 표시만 해주고 뒤집혔는지 여부만 확인해주면 된다.</p>
</blockquote>
</li>
<li><p>D(첫번째 요소 삭제) 시에</p>
<ul>
<li>!isReversed(뒤집X): dq.poll() 로 앞 요소 삭제<ul>
<li>isReversed(뒤집O): dq.pollLast()로 뒤 요소 삭제 -&gt; 뒤집혔다고 가정하면 뒤가 앞이되므로</li>
<li>결과 출력을 재구성 해줘야한다.</li>
<li><strong>출력 구성 과정</strong></li>
<li><blockquote>
<p>에러 여부 확인 </p>
</blockquote>
</li>
<li><blockquote>
<p>StringBuilder 에 &quot;[&quot; 넣기 </p>
</blockquote>
</li>
<li><blockquote>
<p>뒤집힘 여부 확인 </p>
</blockquote>
</li>
<li><blockquote>
<p>dq.size()-1 만큼만 StringBuilder 에 추가(쉼표를 붙여줘야하므로)</p>
</blockquote>
</li>
<li>!isReversed(뒤집X): dq.poll() 로 앞 요소 부터 StringBuilder 넣기</li>
</ul>
</li>
<li>isReversed(뒤집O): dq.pollLast()로 뒤 요소 부터 Strigbuilder 넣기
-&gt; StringBuilder에 &quot;]&quot; 넣기</li>
</ul>
<br />

</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/conam/post/f83e52b9-ac37-4e74-a215-9ecc05d7fee0/image.png" /></p>
<br />


<h1 id="💖-정답-코드">💖 정답 코드</h1>
<pre><code> /** 백준 5430.G5.AC - java 풀이 **/
/**
 *## 체감 난이도 ##
 *- 딱 G5 정도로 느껴졌다
 *- 구현에만 신경쓰는 문제면 되는 줄 알았으나 시간 단축, 출력에 대해 깊이 고민해야 하는 문제였다.
 *- Deque 를 마음껏 활용해 볼 수 있는 문제
 *## 핵심 내용 ##
 *- 자료구조 전체를 뒤집을 생각하지 말고 출력만 앞, 뒤로 바꿔주면 된다.
 *- 정답 출력이 공백을 허용하지 않으므로 출력 포맷을 직접 재구성해야한다.
 *- 코드 고민 + 시간 단축 + 구현 디테일 모두 신경 써야하는 문제
 **/
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.util.*;
public class Main {
    static int T;
    static char[] p;
    static Deque&lt;Integer&gt; dq;
    static boolean isReversed, error; // 뒤집기, 에러 여부 판단

    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();
        StringTokenizer st;

        T = Integer.parseInt(br.readLine());

        while(T-- &gt; 0) {
            p = br.readLine().toCharArray(); // 문자열을 문자 배열로 바꿈
            int n = Integer.parseInt(br.readLine());
            st = new StringTokenizer(br.readLine(), &quot;, []&quot;); // 구분자 여러개 설정
            dq = new ArrayDeque&lt;&gt;();

            for (int i = 0; i &lt; n; i++) {
              dq.offer(Integer.parseInt(st.nextToken()));
            }

            isReversed = false;
            error = false;

            for (char c : p) {
                if (c == 'R') {
                    isReversed = !isReversed; // 뒤집기일 경우 true/false 만 바꿈. 매번 자료구조 뒤집을 필요 X
                }
                else if (!D()) {
                    sb.append(&quot;error\n&quot;);
                    error = true;
                    break;
                }
            }

            if (!error) {
                sb.append(&quot;[&quot;);

                if (!dq.isEmpty()) {
                    int dqSize = dq.size();

                    if(!isReversed) { // 뒤집어져있지 않으면 앞에서부터 차례로 넣기
                        while(dqSize-- &gt; 1) { // 마지막 요소 전까지 ',' 붙여야 하므로
                            sb.append(dq.poll()).append(&quot;,&quot;);
                        }

                        sb.append(dq.poll());
                    }
                    else { // 뒤집어져 있으면 뒤에서부터 차례로 넣기
                        while(dqSize-- &gt; 1) {
                            sb.append(dq.pollLast()).append(&quot;,&quot;);
                        }

                        sb.append(dq.pollLast());
                    }
                }

                sb.append(&quot;]\n&quot;);
            }
        }

        bw.write(sb.toString());
        bw.flush();
        bw.close();
        br.close();
    }

    private static boolean D() {
        if(dq.isEmpty()) return false; // 비어있으면 false 반환

        if (!isReversed) { // 뒤집어지지 않으면 앞요소 삭제
            dq.poll();
        }
        else { // 뒤집힌 상태이면 뒷요소 삭제
            dq.pollLast();
        }
        return true;
    }
}</code></pre>