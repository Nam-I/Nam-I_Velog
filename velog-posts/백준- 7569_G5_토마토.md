<h1 id="✔-문제">✔ 문제</h1>
<blockquote>
<p>철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/conam/post/c172ed72-9734-4836-858c-5a370a90a41a/image.png" /></p>
<blockquote>
<p>창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.
토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.</p>
</blockquote>
<h1 id="✔-입력">✔ 입력</h1>
<blockquote>
<p>첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다. 
토마토가 하나 이상 있는 경우만 입력으로 주어진다.</p>
</blockquote>
<h1 id="✔-출력">✔ 출력</h1>
<blockquote>
<p>여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.</p>
</blockquote>
<br />

<pre><code>// 백준 7569.G5.토마토 - java 풀이
/**
 * ##체감난이도##
 * - 알고리즘 보다는 세부 구현으로 난이도를 나눈 문제이다. 
 * - 문제의 방향성을 잡기는 어렵지 않았으나 조금 더 생각해야 하는 부분들이 있어서 쉽게 풀리지는 않았다.
 * ##핵심 내용##
 * - bfs -&gt; 큐 활용
 * - Queue&lt;Point&gt; q = new LinkedList&lt;&gt;();
 * - 상, 하, 좌, 우, 위, 아래 6방향 확인하는 문제 기억해두기

 */

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

class Point { // 익은 토마토의 좌표 저장하는 객체
    int h;
    int x;
    int y;

    Point(int h, int x, int y) {
        this.h = h;
        this.x = x;
        this.y = y;
    }
}


public class Main{
    static int M;
    static int N;
    static int H;
    static int[][][] box;
    static Queue&lt;Point&gt; q = new LinkedList&lt;&gt;(); //ArrayDeque 자료형 알아보기

    static int[] dh = {0, 0, 0, 0, 1, -1}; // 상, 하, 좌, 위, 아래
    static int[] dx = {-1, 1, 0, 0, 0, 0};
    static int[] dy = {0, 0, -1, 1, 0, 0};

    public static void main (String args[]) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st =  new StringTokenizer(br.readLine());

        M = Integer.parseInt(st.nextToken());
        N = Integer.parseInt(st.nextToken());
        H = Integer.parseInt(st.nextToken());
        box = new int[H+1][N+1][M+1]; // check 함수에서 h &gt; H -1 이런 식으로 비교하지 않고 h &gt; H 이렇게 바로 비교하기 위해서

        for (int i = 1; i &lt;= H; i++) {
            for (int j = 1; j &lt;= N; j++) {
                st = new StringTokenizer(br.readLine());
                for (int k = 1; k &lt;= M; k++) {
                    box[i][j][k] = Integer.parseInt(st.nextToken()); // box 에 상자 토마토 정보 넣기

                    if (box[i][j][k]== 1) {
                        q.offer(new Point(i, j, k)); // 익은 토마토는 바로 탐색 시작 지점으로 쓰기 위해 큐에 넣기
                    }
                }
            }
        }

        bw.write(bfs() + &quot;\n&quot;);
        bw.flush();
        bw.close();
        br.close();
    }

    static int bfs(){ // 상, 하, 좌, 우, 위, 아래로 이동하면 탐색
        while (!q.isEmpty()) {
            Point point = q.poll();

            int height = point.h;
            int row = point.x;
            int col = point.y;

            for (int i = 0; i &lt; 6; i++) {
                int moveHeight = height + dh[i];
                int moveRow = row + dx[i];
                int moveCol = col + dy[i];

                if (check(moveHeight, moveRow, moveCol)) {
                    q.offer(new Point(moveHeight, moveRow, moveCol));
                    box[moveHeight][moveRow][moveCol] = box[height][row][col] + 1;
                }
            }
        }

        int result = Integer.MIN_VALUE;

        for (int i = 1; i &lt;= H; i++) {
            for (int j = 1; j &lt;= N; j++) {
                for (int k = 1; k &lt;= M; k++) {
                    if (box[i][j][k] == 0) return -1; // 하나라도 익지 않은게 있다면 반환

                    result = Math.max(result, box[i][j][k]); // 기존 값보다 큰 값이 있으면 갱신
                }
            }
        }

        if (result == 1) return 0; // 저장될 때 부터 모든 토마토가 익어있는 경우

        return result - 1; // 처음 저장될 때는 일수로 치지 않으므로 -1 해서 반환

    }

    static boolean check(int h, int x, int y) { // 높이, 행, 열 값이 범위 내부인지 확인
        if (h &lt; 1 || h &gt; H || x &lt; 1 || x &gt; N || y &lt; 1 || y &gt; M){
            return false;
        }

        if (box[h][x][y] == 0) return true;

        return false;

    }

}</code></pre><p><a href="https://www.acmicpc.net/submit/7569/100343234">백준: 7569.G5.토마토</a></p>